---
title: 御网杯 WP
date: '2025-05-12 13:18:12'
updated: '2025-05-12 13:20:13'
---
## 0x01 Canary
**题目截图**

![](/images/6b1d021e258da8d09cc35a3c394252b0.png)

解题思路

程序模拟了canary机制，但是可以利用程序逻辑，在选项1当中的read进行栈溢出，覆盖到栈上的v4并同时布置好ROP链，从而继续循环，再在选项2当中恢复程序的“canary”，然后在选项3当中退出循环，进入程序返回流程，从而getshell



## 0x02 ez_pwn
题目截图

![](/images/6c959b5fc02d9bb364ad1c093ce9cfb2.png)

![](/images/48bbf6716eaede84b78cd7bfc5ef849f.png)

解题思路

一上来就把标准输出关闭了，但是可以利用标准错误流来输出libc地址，使用ret2csu技巧，控制寄存器，从而成功输出read函数的libc地址，然后再次回到main函数从而再次调用read来写入ROP链getshell



## 0x03 easy-签到题
题目截图

![](/images/fcabb53931f452015aed67b146681c55.png)

![](/images/aabe6cd6395cf71cd1f396c4457b3652.png)

解题思路

将压缩包当中exe放到010editor当中查看，复制内容进行base32解密和base1

6解密就可以获得flag





## 0x04 被折叠的显影图纸
题目截图

![](/images/0241d5c6be28d9b9c257ae5da7b3e3cb.png)

解题思路

将xls文件放到随波逐流工具箱当中就可以看到flag，同理放010editor查找flag字符串也是可以的



## 0x05 cry_rsa
题目截图

![](/images/3040d0981e43d265ee1a6dd18711cb3a.png)

解题思路

脚本：

```c
p = 473398607161
q = 4511491
e = 19

phi = (p - 1) * (q - 1)
d = pow(e, -1, phi)
flag = d + 2
print(f"flag{{{flag}}}")
```



## 0x06 ez_xor
题目截图

![](/images/d4307c34ca9ca2543e5c47ca805060fa.png)

解题思路

预估前面5f-55-58-5e四项是flag字符串经过异或后得到的结果，经过计算可以算出异或的数是0x39，再将整个字符串异或得到flag



## 0x07 easy_misc
题目截图

![](/images/04d5f28a0e04caa9b321dba74c10f093.png)

解题思路

先十进制转字符串，然后是base64和base58，最后是Rot13解码



## 0x08 baby_rsa
题目截图

![](/images/a71b63806163d0af23e07173f2044d2b.png)

![](/images/14f009485b0964430ba93859cb3c4dd6.png)

解题思路

附件当中的exe放进010editor当中可以查看到原来的python脚本，写脚本解密rsa即可

```c
from Crypto.Util.number import long_to_bytes
from gmpy2 import isqrt, mpz, powmod, invert

N=mpz(12194420073815392880989031611545296854145241675320130314821394843436947373331080911787176737202940676809674543138807024739454432089096794532016797246441325729856528664071322968428804098069997196490382286126389331179054971927655320978298979794245379000336635795490242027519669217784433367021578247340154647762800402140321022659272383087544476178802025951768015423972182045405466448431557625201012332239774962902750073900383993300146193300485117217319794356652729502100167668439007925004769118070105324664379141623816256895933959211381114172778535296409639317535751005960540737044457986793503218555306862743329296169569)
e = 65537
c=mpz(4504811333111877209539001665516391567038109992884271089537302226304395434343112574404626060854962818378560852067621253927330725244984869198505556722509058098660083054715146670767687120587049288861063202617507262871279819211231233198070574538845161629806932541832207041112786336441975087351873537350203469642198999219863581040927505152110051313011073115724502567261524181865883874517555848163026240201856207626237859665607255740790404039098444452158216907752375078054615802613066229766343714317550472079224694798552886759103668349270682843916307652213810947814618810706997339302734827571635179684652559512873381672063)

def fermat_factorization(n):
a = isqrt(n) + 1
b2 = a * a - n
while True:
b = isqrt(b2)
if b * b == b2:
return (a + b, a - b)
a += 1
b2 = a * a - n

p, q = fermat_factorization(N)
assert p * q == N

phi = (p - 1) * (q - 1)
d = invert(e, phi)
m = powmod(c, d, N)
flag = long_to_bytes(m).decode()

print("Flag:", flag)
```

