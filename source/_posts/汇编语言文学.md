---
title: 汇编语言文学
date: '2024-12-26 16:16:47'
updated: '2025-05-14 21:11:37'
---
`leave`=`mov rsp,rbp ; pop rbp`

`ret`=`pop rip`

以下内容总结自《汇编语言（第 4 版）》

## 第二章 寄存器
+ 64 位：`RAX`大小八个字节，
+ 32 位：`EAX`大小四个字节，
+ 16 位：`AX`大小两个字节，可以分成`AL`(low)低位、`AH`(high)高位 两个单字节（八位）寄存器

> <font style="color:#000000;">在写 shellcode 的时候用低位的寄存器可以节省字节数</font>
>

<font style="background-color:#FBDE28;">八位(bit)为一个字节(byte)，两个字节(byte)为一个字(word)</font>

汇编指令当中，以十六进制表示的数据后面加上 H，以二进制表示的数据后加上 B

地址加法器采用 `物理地址 = 段地址*16 + 偏移地址` 的方式合成物理地址



### 寄存器 `CS`、`IP`
`CS`寄存器：（Code Segment，CS）

段寄存器，32 位、64 位都是这个，一般存放代码段

`IP`寄存器：（Instruction Pointer，IP）

指令寄存器，指向下一个指令，32 位为`EIP`，64 位为`RIP`



## 第三章 寄存器（内存访问）
在内存当中存放的数据大部分都是小端序，即逆序

`[idata]`向 idata 指向的地址取值（idata 指常量）

段寄存器不可以进行算数运算



### 寄存器 `SP`、`BP`
`SP`寄存器：（Stack Pointer，SP）指向当前栈顶

32 位为`ESP`，64 位为`RSP`

> <font style="color:#000000;">栈空时</font>`<font style="color:#000000;">SP</font>`<font style="color:#000000;">指向栈空间最高地址单位的下一个单位</font>
>



`BP`寄存器：（Base Pointer，BP）指向当前栈底，通常作为栈中位置的基准（base）

32 位为`EBP`，64 位为`RBP`

+ 执行`push`指令时：先改变`SP`，再向将数据传进`SS:SP`处
+ 执行`pop`指令时：先将数据传出，再改变`SP`

> 段的定义完全是按照程序员的目的来的，并没有固定说 data 段、code 段之类的，
>
> 但是应该按目的给段命名
>



## 第四章 （第一个程序）
### 伪指令 `assume`、`segment`、`end`
伪指令是给编译器的标记

标记与段相关的寄存器的伪指令：

```plain
assume cs:codesg ;把codesg段与CS寄存器联系起来，但这只是提示编译器有这个联系，不是硬性的
```

标记段的伪指令：

```plain
XXX segment
  ...
  ...
XXX ends
```

标记汇编程序结束的伪指令：`end`（与 XXX ends 不一样）



程序返回：

```plain
mov ax,4c00h
int 21h
```



汇编指令到可执行文件的过程：

![画板](/images/9663385d33d8d8edfaa1e9c92752ef00.jpeg)

其中库文件：

<font style="background-color:#FBDE28;">Linux 系统当中，静态库后缀名一般为</font>`<font style="background-color:#FBDE28;">.a</font>`<font style="background-color:#FBDE28;">，动态库一般为</font>`<font style="background-color:#FBDE28;">.so.版本号</font>`

<font style="background-color:#FBDE28;">Windows 系统当中，静态库后缀名一般为</font>`<font style="background-color:#FBDE28;">.lib</font>`<font style="background-color:#FBDE28;">，动态库一般为</font>`<font style="background-color:#FBDE28;">.dll</font>`

<font style="background-color:#FBDE28;"></font>

## 第五章 [BX] 和 loop 指令
`[register]`从寄存器的地址指向的内存取数据

```plain
assume cs:codesg
code segment
  ...
s:... ;这里的s是标号，是代表段内的一个地址的符号
  ...
  ...
code ends
end
```

注意：

`<font style="background-color:#FBDE28;">[register1 + register2 + idata]</font>`

<font style="background-color:#FBDE28;">=</font>`<font style="background-color:#FBDE28;">idata[register1][register2]</font>`

<font style="background-color:#FBDE28;">=</font>`<font style="background-color:#FBDE28;">[register1][register2].idata</font>`

总之，寄存器必须放在`[]`里面



### 指令 `loop`、`inc`、`dec`
`loop`用`CX`寄存器作为循环计数寄存器， 

```plain
mov cx, idata ;这里决定loop循环几次
s:... ;这里的s是标号，是代表段内的一个地址的符号
  ...
  ...
  loop s ;loop+标号相当于循环执行这两个之间的指令，直到CX寄存器为零离开循环
  ...
```

汇编语言要求运算对象类型要一致，但是赋值不要求一致（低赋高数值安全，高赋低可能数值截断）

可以在 `[]`前标明段地址从哪个寄存器取，从而实现读写其他段的地址，例如：

`CS:[idata]`，`CS:`称为段前缀



`inc register`，让寄存器加一

`dec register`，让寄存器减一

## 第六章 包含多个段的程序
在源程序中定义段来进行内存空间的获取，因为在程序被加载进内存时，对应段的内存空间就可以被使用

### 伪指令 `d*（define *）`、`start`
`dw idata`（define word）定义字型数据，后面的 idata 应该以 ffffh 的形式写

可以 以`dw 0001h,0002h,0003h...`的形式定义一系列数据

类似的还有`db`（define byte）定义字节型数据，可以用来存放字符

`dd`（define double word）定义双字型数据



用于标记程序的入口，在程序结束处的`end`后边要加上 `start`

```plain
assume cs:codesg
code segment
      ...
start:... ;这里的start是程序入口，调用此程序时将会从此处开始执行
      ...
      ...
code ends
end start
```

可以直接使用`segmentname`来表示对应段的基础地址，类似标号的用法，例如：

`mov ax, code`将 code 段的初始地址传入了`AX`寄存器当中



## 第七章 更灵活的定位内存地址的方法
在汇编程序当中，字符(串)是用`'......'`的方式指明的

大小写字母的修改：

```plain
and al,11011111B ;将al中的ASCII码的第五位改为0，变成大写字母
or al,00100000B ;将al中的ASCII码的第五位改为1，变成小写字母
```

上面这段在 C 语言当中相当于：

```c
a=a&0xDF; //与操作将ASCII码第五位改为0，变成大写字母
b=b|0x20; //或操作将ASCII码第五位改为0，变成小写字母
```



### 寄存器 `SI`、`DI`
+ SI (Source Index): 用于指向源数据的内存位置。在使用 `MOVSB`, `MOVSW`, `CMPSB` 等指令时，`SI` 存储源数据的位置。
+ DI (Destination Index): 用于指向目标数据的内存位置。在执行类似 `MOVSB`, `MOVSW` 等指令时，`DI` 存储目标内存的位置

在 16 位当中，`SI`和`DI`跟`BX`功能相近，

在 32 位中为`ESI`和`EDI`，

+ SI 和 ESI (源寄存器): 主要用于存储源数据的地址（通常在字符串操作和内存拷贝中作为源）。
+ DI 和 EDI (目标寄存器): 主要用于存储目标数据的地址（通常在字符串操作和内存拷贝中作为目标）

在 64 位当中为`RSI`和`RDI`，用来传送函数调用的参数



### 嵌套循环
因为`loop`指令只能用`CX`寄存器作为循环计数器，所以在执行内层循环之前要保存当前`CX`寄存器的值

这种需要临时存放数据的情况最适合用栈保存

```plain
    mov cx, ... ;外层循环的次数
s0: push cx ;将外层循环剩余次数压入栈，保存外层循环剩余次数
    mov cx, ... ;内层循环的次数
s1: ... ;内层循环
    loop s1
    pop cx ;将外层循环剩余次数出栈，恢复外层循环剩余次数
    loop s0
```



## 第八章 数据处理的两个基本问题
在 8086CPU 当中，只有`BX``SI``DI``BP`这四个寄存器可以用在`[]`中来进行内存单元的寻址

补充：在 32 位和 64 位 CPU 当中则是`EBX``EDI``ESI``EBP`和`RBX``RDI``RSI``RBP`

<font style="background-color:#FBDE28;">在</font>`<font style="background-color:#FBDE28;">[]</font>`<font style="background-color:#FBDE28;">当中，上面四种寄存器可以单独出现，或只能以下面四种组合出现</font>

![画板](/images/dbc8d6b8c952cea3aa04e54a213ba23a.jpeg)

只要在`[]`当中使用`*BP`寄存器而没有显性给出段寄存器，则默认`SS`寄存器为段寄存器（栈 stack 相关）

如果时`*BX``*SI``*DI`这三个则默认`DS`寄存器为段寄存器（数据 data 相关）

立即数（idata）

直接包含在机器指令中的数据（执行前就在 CPU 的指令缓冲器中）



### 寻址方式与数据类型
+ 用于结构体（即以类似访问结构体成员的方式寻址）：`[*BX].idata`
+ 用于数组：（即以类似访问数组索引对应值的方式寻址）：`idata[*SI]`，`idata[*DI]`
+ 用于二维数组：（即以类似访问二维数组索引对应值的方式寻址）：`[BX][idata]`



### 数据类型尺寸
1. 通过寄存器类型来确认要处理的数据的尺寸

即根据寄存器是几位来判断字长，从而判断数据是几位的

+ 16 位字长 2 字节
+ 32 位字长 4 字节
+ 64 位字长 8 字节

注意：`DWORD`（double word 双字）、`QWORD`（quad word 四字）

2. 在没有寄存器名存在的情况下，通过操作符`X ptr`来指明内存单元的长度
3. `<font style="background-color:#FBDE28;">PUSH</font>`<font style="background-color:#FBDE28;">只进行字操作</font>



### 指令 `div`
`div 除数`，除法指令

除数：8 或 16 位，存放于寄存器或内存当中

被除数 : 16 或 32 位，16 位存放在 `AX`寄存器当中，32 位存放在`DX`(高16位) 和`AX`(低16位) 两个寄存器当中

结果：

+ 被除数是 16 位将商存在`AL`中，余数存在`AH`中（`AX`的低 8 位和高 8 位）
+ 被除数是 32 位则将商存在`AX`中，余数存在`DX`中



### 操作符 `dup`
与伪指令`db`、`dw`、`dd`配合使用，用来进行数据的重复

例如：

```plain
db 3 dup (1,2,3) ;将1、2、3这三个数据重复三遍，共9个字节
```



## 第九章 转移指令的原理
![画板](/images/fbed43b4e0aa337e525649702ad5b928.jpeg)



### 操作符 `offset`
功能：取得标号的偏移地址（相对于段起始地址的偏移，用补码的形式表示）

例如：

```plain
s: mov ax, offset s ;将标号s相对于当前段起始地址的相对偏移传进AX寄存器
```



`nop`的机器码占一字节

`mov`的两个操作数<font style="background-color:#FBDE28;">不能都是</font>内存地址



### 附注 2 补码
补码是一种编码方式：

先确定用 00000000b~01111111b（二进制）表示 0~127，然后再用它们按位取反再加 1 之后的数据表示相反数，也就是负数

+ 最高位为 1，表示负数
+ 正数的补码取反加 1，为对应的负数的补码；反之亦如此

以补码的形式进行运算，运算后结果仍然满足补码规则



### 指令 `jmp`、`jcxz`
`jmp`指令：

**根据位移进行跳转的**`**jmp**`**指令**

段内短转移（最多向前越过 128 个字节，向后越过 127 个字节）

```plain
jmp short 标号 ;跳转至标号处执行指令
```

段内近转移（最多向前越过 32767 个字节，向后越过 32768 个字节）

```plain
jmp near ptr 标号 ;跳转至标号处执行指令
```

注意：

+ 此时 CPU 在执行`jmp`指令时并不需要转移的目标地址
+ 位移由编译器在编译时计算得出

**转移的目的地址在指令中的**`**jmp**`**指令**

段间转移（又称远转移）

```plain
jmp far ptr 标号 ;跳转至标号处执行指令
```

**转移地址在内存中的**`**jmp**`**指令**

word 类型：

```plain
jmp word ptr 内存单元地址（段内转移） ;跳转至内存单元存储的地址指向的位置执行指令
```

dword 类型：（高字存放目的段地址，低字存放目的偏移地址）

```plain
jmp dword ptr 内存单元地址（段间转移） ;跳转至内存单元存储的地址指向的位置执行指令
```



`**jcxz**`**指令**

有条件转移指令，当寄存器`CX`为 0 时跳转到标号处执行

注意：

+ 所有有条件转移指令都是段内短转移
+ 位移也是由编译器在编译时计算得出

`loop`指令补充：

+ 所有循环指令都是段内短转移



## 第十章 CALL 和 RET 指令
`ret`指令用栈中的数据修改 `IP`寄存器的值，实现近转移

`retf`指令用栈中的数据修改 `CS` 和 `IP` 的值，实现远转移

**根据位移进行转移的 **`**call**`** 指令**

执行`call`指令时，（`call`指令不能实现短转移）

1. 将当前`CS`和`IP`的值压入栈
2. 转移

**转移的目的地址在指令中的**`**call**`**指令**

`call far ptr 标号`实现的是段间转移

**转移地址在寄存器当中的**`**call**`**指令**

`call 16 位寄存器`

**转移地址在内存中的**`**call**`**指令**

1. `call word ptr 内存单元地址`，段内近转移
2. `call dword ptr 内存单元地址`，段间转移

> 具有一定功能的程序段称为子程序
>

### 指令 `mul`
乘法指令，两个相乘的数必须都是 8 位或者都是 16 位

+ 8 位：一个默认放`AL`，另一个放在 8 位寄存器或者字节内存单位
+ 16 位：一个默认`AX`，另一个放在 16 位寄存器或者字内存单位

结果：8 位默认放在`AX`，16 位高位放`DX`、低位放`AX`

```python
mul 寄存器
mul 内存单元
```

内存单元可以用不同的寻址方式给出：

```python
mul bytes ptr ds:[0] ;8位
mul word ptr [bx+si+8] ;16位
```

### 指令 `ret n`
相当于：

```python
pop ip
add sp,n
```

因为用栈传递参数，所以调用者在调用程序的时候要想栈中压入参数，子程序在返回的时候可以用这个指令将栈顶指针修改回调用前的值



字符串以"0"结尾，应该这样定义：

```python
db 'string',0
```

## 第十一章 标志寄存器
影响标志寄存器的大都是<font style="background-color:#FBDE28;">运算指令</font>，<font style="background-color:#FBDE28;">传送指令</font>一般对标志寄存器没有影响

标志寄存器每一位都有专门的含义：

![](/images/57b0faff535850155b380ee71e0aaee6.png)

1. ZF 标志（Zero Flag）：零标志位，记录相关指令执行后结果是否为零
2. PF 标志（Parity Flag）：奇偶标志位，记录相关指令执行后的结果所有 bit 位中 1 的个数是否为偶数
3. SF 标志（Sign Flag）：符号标志位，记录相关指令执行后结果是否为负数
4. CF 标志（Carry Flag）：进位标志位，记录相关<font style="background-color:#FBDE28;">无符号整数</font>加减法时候发生进位或者借位
5. OF 标志（Overflow Flag）：溢出标志位，记录相关<font style="background-color:#FBDE28;">有符号数运算</font>的结果是否发生了溢出

### 指令 `adc`、`sbb`、`cmp`
`adc`：带进位加法指令，利用了 CF 标志的进位值

```python
adc 操作对象1,操作对象2
```

跟 `add` 一样的用法只是在相加时还会加上 CF 上面的值（1 或 0）

`sbb`：带借位减法指令，和`adc`一样利用了 CF 标志的进位值，在 1-2 的同时还会减去 CF 上面的值（1 或 0）

`cmp`：比较指令

```python
cmp 操作对象1,操作对象2
```

相当于减法指令，但是不保存结果，只按照结果修改 CF 标志

### 条件转移指令系列
要配合`cmp`指令才能实现`含义`当中的效果

| 指令 | 含义 | 检测的相关标志位 |
| --- | --- | --- |
| je | 等于转移 (equal) | ZF=1 |
| jne | 不等于转移 (not equal) | ZF=0 |
| jb | 低于转移 (below) | CF=1 |
| jnb | 不低于转移 (not below) | CF=0 |
| ja | 高于转移 (above) | CF=0 & ZF=0 |
| jna | 不高于转移 (not above) | CF=1 & ZF=1 |


6. DF 标志（Direction Flag）：方向标志位，在串处理指令中控制`SI`、`DI`的增减

### 串传送指令系列
`movsb`相当于（伪代码）：

```python
mov es:[di],byte ptr ds:[si] ;将ds:[si]中内容存入es:[di]

如果DF=0：
inc si
inc di ;从低地址向高地址逐字节复制到对应位置

如果DF=1：
dec si
dec di ;从高地址向低地址逐字节复制到对应位置
```

也可以传送字型数据：`movsw`

 `movsb`、`movsw`一般和`rep`配合使用：

```python
rep movsb
```

相当于根据`CX`的值重复单个语句（repeat）

```python
s:movsb
  loop s
```

`cld`指令：将标志寄存器的 DF 设置为 0（低->高）

`std`指令：将标志寄存器的 DF 设置为 1（高->低）

### 指令 `pushf`、`popf`
将标志寄存器入栈、出栈

## 第十二章 内中断
中断类型码用来标识中断信息的来源，为一个字节型数据

中断信息的来源简称中断源

### 中断向量表
CPU 用中断类型码通过中断类型码找到对应的中断处理程序的入口地址

中断向量就是中断处理程序的入口地址

### 指令 `iret`
中断处理程序的返回指令，功能用汇编语法描述相当于：

```plain
pop IP
pop CS
popf
```



可以利用加粗的指令来计算出两个标号之间的距离，这里也就是 do0 的长度

![](/images/113e3dfed96f2ef205a2b66a8bdc94a3.png)

“ - ”减号，是编译器识别的运算符号，编译器可以用它来进行两个常数的减法

汇编编译器可以处理表达式，

比如指令：`mov ax,(5+3)*5/10`，就会被编译器处理为指令：`mov ax,4`

### 单步中断
 CPU 在执行完一条指令之后，如果检测到标志寄存器的 TF 位为 1，则产生单步中断，引发中断过程。

单步中断的中断类型码为 1

在进入中断处理程序之前，要设置 TF=0

单步中断过程：

1. 取得中断类型码 N
2. 标志寄存器入栈，TF=0、IF=0
3. `CS`、`IP` 入栈
4. (`IP`)=(N*$)，(`CS`)=(N*4+2)

要注意的点：

CPU 在执行完设置`SS`的指令后不响应任何中断，这是为了能够连续设置`SS`和`SP`指向正确的栈顶

## 第十三章 `int` 指令
`int n`，n 为中断类型码，指令的功能是引发中断过程

`int`指令和`iret`指令的配合使用跟`call`指令和`ret`指令的配合使用相似

### BIOS 和 DOS 提供的中断例程
在系统板的 ROM 中存放着一套程序，称为 BIOS（基本输入输出系统），主要包含以下几部分内容：

1. 硬件系统的检测和初始化程序
2. 外部中断和内部中断的中断例程
3. 用于对硬件设备进行 I/O 操作的中断例程
4. 其他和硬件系统相关的中断例程

可以用`int`指令直接调用 BIOS 和 DOS 提供的中断例程

BIOS 和 DOS 提供的中断例程都用`ah`来传递内部子程序的编号



要显示的字符串要用`"$"`作为结束符，显示字符串会直到遇见`"$"`，本身不显示，只起到边界作用

## 第十四章 端口
CPU 可以直接读写一下三个地方的数据：

1. CPU 内部的寄存器
2. 内存单元
3. 端口

### 指令 `in`、`out`
端口的读写指令只有这两条，分别用于从端口读取数据和往端口写入数据

```plain
in al,60h  ;从60h号端口读入一个字节（al大小为一个字节）
```

在`in`、`out`指令中，只能使用`AX`或`AL`来存放从端口中读入的数据或要发送到端口中的数据

访问 8 位端口时用`AL`，访问 16 位端口时用`AX`

### CMOS RAM 芯片
1. 包含一个实时钟和一个有 128 个存储单元的 RAM 存储器(早期的计算机为 64 个字节)。
2. 该芯片靠电池供电。所以，关机后其内部的实时钟仍可正常工作，RAM 中的信息不丢失。
3. 128 个字节的 RAM 中，内部实时钟占用 0~0dh 单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS 程序读取。BIOS 也提供了相关的程序，使我们可以在开机的时候配置 CMOS RAM 中的系统信息。
4. 该芯片内部有两个端口，端口地址为 70h 和 71h。CPU 通过这两个端口来读写CMOS RAM.
5. 70h 为地址端口，存放要访问的 CMOS RAM 单元的地址;71h 为数据端口，存放从选定的 CMOS RAM 单元中读取的数据，或要写入到其中的数据。可见，CPU 对CMOS RAM 的读写分两步进行，比如，读CMOS RAM 的2号单元：
+ 将2送入端口 70h;
+ 从端口 71h 读出2号单元的内容。

在 CMOS RAM 中，存放着当前的时间:年、月、日、时、分、秒。

这6个信息的长度都为1个字节，存放单元为:`秒:0``分:2``时:4``日:7``月:8``年:9`

这些数据以 BCD 码的方式存放。

#### BCD 码
BCD 码是以4位二进制数表示十进制数码的编码方法，如下所示。

十进制数码：01234678 

对应的BCD码：0000 0001 0010 0011 0100 0101 0110 0111 1000 1001

比如，数值 26，用 BCD 码表示为:0010 0110。

可见，一个字节可表示两个 BCD 码。则 CMOS RAM 存储时间信息的单元中，存储了用两个 BCD 码表示的两位十进制数，高 4 位的 BCD 码表示十位，低 4 位的 BCD 码表示个位。比如，00010100b 表示14。

BCD 码值=十进制数码值，BCD 码值+30h=十进制数对应的 ASCII 码



### 指令 `shl`、`shr`
`shl`是逻辑左移指令，功能为：

1. 将一个寄存器或内存单位中的数据向左移位
2. <font style="background-color:#FBDE28;">将最后移出的一位写入</font>`<font style="background-color:#FBDE28;">CF</font>`<font style="background-color:#FBDE28;">中</font>
3. 最低位用 0 补充

例如：

```plain
shl al,1  ;将al中的数据左移一位
```

如果移动的位数大于 1 时，必须将移动位数放在`CL`中

`shr`是逻辑右移指令，和`shl`所进行的操作正好相反

## 第十五章 外中断
外中断源一共有两类：

1. 可屏蔽中断

当 CPU 检测到可屏蔽中断信号时，如果 IF=1，则 CPU 在执行完当前指令后响应中断，引发中断过程；

如果 IF=0，则不响应可屏蔽中断

可屏蔽中断所引发的中断过程除第一步（中断类型码的来源）之外和内中断的过程相同，是因为可屏蔽中断信息来自 CPU 外部，中断类型码是通过数据总线送入 CPU 的；而内中断的类型码是在 CPU 内部产生的

### 指令 `sti`、`cli`
`sti`，设置 IF 为 1；

`cli`，设置 IF 为 0；



2. 不可屏蔽中断

不可屏蔽中断是 CPU 必须响应的外中断

+ 几乎所有由外设引发的外中断都是可屏蔽中断。
+ 不可屏蔽中断是在系统中有必须处理的紧急情况发生时用来通知 CPU 的中断信息



键盘的处理过程：

1. 键盘输入

一般将按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码

通码的第七位为 0，断码的第七位为 1，即：断码=通码+80h

2. 引发 9 号中断
3. 执行 9 号中断例程



### 指令系统总结
![](/images/0476ea426eca89e6354cde9f1b3bb451.png)

![](/images/c95ee27cdc436250b9ffb0efebb9f690.png)

## 第十六章 直接定址表
### 数据标号
先看之前的标号：

```plain
a : db 1,2,3,4,5,6
```

还可以用数据标号，不但表示内存单元的地址，还可以表示内存单元的长度：

```plain
a db 1,2,3,4,5,6
```

数据标号后面没有`":"`

#### 用法
同一个段中：

![](/images/aea7c6928e1894c176b35002fc8babc9.png)

在其他段中：

要先将对应段地址跟相关的寄存器联系起来，用指令对段寄存器进行设置

![](/images/195109c491f0d816176ae4fd40106330.png)

然后可以像在同一个段中一样用数据标号

![](/images/3e31909ee89a51c03f847ce99758ca7b.png)



可以将标号当作数据来定义，编译器会将标号所表示的地址当作数据的值

```plain
c dw a,b
```

相当于：

```plain
c dw offset a,offset b
```

### 操作符 `seg`
`seg a`取得标号的段地址

### 直接定址表
为数据建立新的映射关系，例如将字节型数据转成十六进制的形式

做法：建立一张表，表中依次存储字符"0"~"F"，可以通过 0~15 直接查找到对应的字符

![](/images/1b5070114c77843b509dd1c04a3224df.png)

![](/images/5a9f94599f7cdabd3ceb2d25152dc5e9.png)

这种可以依据数据直接计算出所要找到的元素的位置的表，就叫做直接定址表

在直接定址表中存储子程序的地址，从而实现不同子程序的调用

如果要加入一个新功能子程序，只需要在地址表中加入它的入口地址就可以了

## 第十七章 使用 BIOS 进行键盘输入和磁盘读写
BIOS 的 int 9 中断例程和 int 16h 中断例程是一对相互配合的程序，int 9 中断例程在有键按下时向键盘缓冲区中写入数据，int 16h 中断例程在应用程序调用时从缓冲区中读出数据

---

至此完结...

