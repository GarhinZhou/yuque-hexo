---
title: 《程序员的自我修养》
date: '2025-07-23 15:50:45'
updated: '2025-07-24 16:22:13'
---
———链接、装载与库

这个书名怎么看怎么像梗（？），也是整理一些重点来这里

## 第一章
API：应用程序编程接口`(Application Programming Interface)`

Linux 下 Glibc 库提供 POSIX 的 API，Windows 的运行库提供 Windows API

运行库使用操作系统提供的系统调用接口`(System call Interface)`

操作系统使用硬件接口`(Hardware Specification)`



繁琐的硬件细节全都交给了操作系统，具体地讲是操作系统中的硬件驱动`(Device Driver)`程序来完成。驱动程序可以看作是操作系统的一部分，它往往跟操作系统内核一起运行在特权级，但它又与操作系统内核之间有一定的独立性，使得驱动程序有比较好的灵活性



现代的硬盘普遍使用一种叫做LBA`(Logical Block Address)`的方式，即整个硬盘中所有的扇区从0开始编号，一直到 最后一个扇区，这个扇区编号叫做逻辑扇区号

### 线程
线程`(Thread)`，有时被称为轻量级进程`(Lightweight Process，LWP`)，是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针(PC)、寄存器集合和堆栈组成。通常意义上，一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间(包括代码 段、数据段、堆等)及一些进程级的资源(如打开文件和信号)

#### 线程局部存储
Thread Local Storage，TLS。是某些操作系统为线程单独提供的私有空间

#### ![](/images/d18b393293198a9654f26b925565fd38.png)
当线程数量小于处理器数量时（且操作系统支持多处理器），线程的并发时真正的并发

不断在处理器上切换不同线程的行文称为线程调度

+ 运行（Running）：线程正在执行
+ 就绪（Ready）：线程可以立即执行，但是 CPU 正在被占用
+ 等待（Waiting）：线程正在等待某一事件（通常是 I/O 或同步）发生

运行中的线程拥有一段可以执行的时间，这段时间称为时间片（Time Slice）

调度方法有：优先级调度和轮转法

频繁等待的线程称为 IO 密集型线程`(IO Bound Thread)`，很少等待的线程称为 CPU 密集型线程`(CPU Bound Thread)`



#### ![](/images/0c5bf5106507360c7f81f2177879115e.png)
#### fork
fork 产生新任务的速度非常快，因为fork并不复制原任务的内存空间，而是和原任务一起共享一个写时复制`(Copy on Write，COW)`的内存空间。写时复制指的是两个任务可以同时自由地读取内存，但任意一个任务试图对内存进行修改时，内存就会复制一份提供给修改方单独使用，以免影响到其他的任务使用

#### 线程安全
操作在多线程环境下会出现错误是因为这个操作被编译为汇编代码之后不止一条指令，因此在执行的时候可能执行了一半就被调度系统打断，去执行别的代码

单指令的操作称为原子的`(Atomic)`

##### 同步与锁
为了避免多个线程同时读写同一个数据而产生不可预料的后果，我们需要将各个线程对同一个数据的访问**<font style="color:#117CEE;">同步</font>**`**<font style="color:#117CEE;">(Synchronization)</font>**`。所谓同步，既是指在一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问。如此，对数据的访问被原子化了

同步的最常见方法是使用**<font style="color:#117CEE;">锁</font>**`**<font style="color:#117CEE;">(Lock)</font>**`。锁是一种非强制机制，每一个线程在访问数据或资源之前首先试图获取`(Acquire)`锁，并在访问结束之后释放`(Release)`锁。在锁已经被占用的时候试图获取锁时，线程会等待，直到锁重新可用

**<font style="color:#117CEE;">二元信号量</font>**`**<font style="color:#117CEE;">(Binary Semaphore)</font>**`是最简单的一种锁，它只有两种状态：占用与非占用。它适合只能被唯一一个线程独占访问的资源。当二元信号量处于非占用状态时，第一个试图获取该二元信号量的线程会获得该锁，并将二元信号量置为占用状态，此后其他的所有试图获取该二元信号量的线程将会等待，直到该锁被释放。

对于允许多个线程并发访问的资源，**<font style="color:#117CEE;">多元信号量简称信号量</font>**`**<font style="color:#117CEE;">(Semaphore)</font>**`，它是一个很好的选择。一个初始值为N的信号量允许N个线程并发访问。线程访问资源的时候首先获取信号量，进行如下操作:

+ 将信号量的值减1
+ 如果信号量的值小于0，则进入等待状态，否则继续执行

访问完资源之后，线程释放信号量，进行如下操作: 

+ 将信号量的值加1
+ 如果信号量的值小于1，唤醒一个等待中的线程

**<font style="color:#117CEE;">互斥量</font>**`**<font style="color:#117CEE;">(Mutex)</font>**`和二元信号量很类似，资源仅同时允许一个线程访问，但和信号量不同的是，信号量在整个系统可以被任意线程获取并释放，也就是说，同一个信号量可以被系统中的一个线程获取之后由另一个线程释放。而互斥量则要求哪个线程获取了互斥量，哪个线程就要负责释放这个锁，其他线程越俎代庖去释放互斥量是无效的

**<font style="color:#117CEE;">临界区</font>**`**<font style="color:#117CEE;">(Critical Section)</font>**`是比互斥量更加严格的同步手段。在术语中，把临界区的锁的获取称为进入临界区，而把锁的释放称为离开临界区。临界区和互斥量与信号量的区别在于，互斥量和信号量在系统的任何进程里都是可见的，也就是说，一个进程创建了一个互斥量或信号量，另一个进程试图去获取该锁是合法的。然而，临界区的作用范围仅限于本进程， 其他的进程无法获取该锁。除此之外，临界区具有和互斥量相同的性质

**<font style="color:#117CEE;">读写锁</font>**`**<font style="color:#117CEE;">(Read-Write Lock)</font>**`致力于一种更加特定的场合的同步。对于一段数据，多个线程同时读取总是没有问题的，但假设操作都不是原子型，只要有任何一个线程试图对这个数据进行修改，就必须使用同步手段来避免出错。如果我们使用上述信号量、互斥量或临界区中的任何一种来进行同步，尽管可以保证程序正确，但对于读取频繁，而仅仅偶尔写入的情况，会显得非常低效。读写锁可以避免这个问题：

![](/images/95b42e8df4e299736bb3705402771c52.png)

**<font style="color:#117CEE;">条件变量</font>**`**<font style="color:#117CEE;">(Condition Variable)</font>**`作为一种同步手段，作用类似于一个栅栏。对于条件变量，线程可以有两种操作，首先线程可以等待条件变量，一个条件变量可以被多个线程等待。其次，线程可以唤醒条件变量，此时某个或所有等待此条件变量的线程都会被唤醒并继续支持。也就是说，使用条件变量可以让许多线程一起等待某个事件的发生，当事件发生时(条件变量被唤醒)，所有的线程可以一起恢复执行

## 第二章
预处理（预编译，Prepressing）->编译（Compilation）->汇编（Assembly）->链接（Linking）

![](/images/8c1bd4a670659d2716c139f9f1a85310.png)

### 预编译
主要处理源代码当中以“#”开头的预编译指令，添加行号和文件名标识

### 编译
编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件，这个过程往往是我们所说的整个程序构建的核心部分，也是最复杂的部分之一

实际上`gcc`这个命令只是这些后台程序的包装，它会根据不同的参数要求去调用预编译编译程序`cc1`、汇编器`as`、链接器`ld`

一般可以分为六步：扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化

![](/images/8f27e8732f5a50348064173439f22421.png)

#### 词法分析
词法分析产生的记号有以下几类：关键字、标识符、字面量和特殊符号

识别的同时扫描器也完成了其他工作：将标识符存放至符号表，将数字、字符串常量存放到文字表

### 汇编
汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译就可以了，“汇编” 这个名字也来源于此

## 第三章
动态链接库（DLL，Dynamic Linking Library）：Windows 的`.dll` 和 Linux 的`.so`

静态链接库（Static Linking Library）：Windows 的`.lib`和 Linux 的`.a`

![](/images/539f0bf65b4763ca7f227dc4997c5e36.png)

![](/images/35ff1ca3c3141d634daf638d148d5077.png)

### 段
`.text`或`.code`：代码段

`.data`：数据段

`.bss`：未初始化的全局变量和局部静态变量预留位置（Block Started by Symbol）

`.rodata`：只读数据段（ro：read only）

![](/images/d92d42bef62d7c4523810d56cece12f6.png)

