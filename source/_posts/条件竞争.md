---
title: 条件竞争
date: '2025-07-25 20:45:49'
updated: '2025-07-26 10:27:30'
---
## CWE-367: TOCTOU Race Condition
TOCTOC (Time-of-check Time-of-use) 指的是程序在使用资源（变量，内存，文件）前会对进行检查，但是在程序使用对应的资源前，该资源却被修改了

### CWE-365: Race Condition in Switch
当程序正在执行 switch 语句时，如果 switch 变量的值被改变，那么就可能造成不可预知的行为。尤其在 case 语句后不写 break 语句的代码，一旦 switch 变量发生改变，很有可能会改变程序原有的逻辑

### CWE-363: Race Condition Enabling Link Following
我们知道 Linux 中提供了两种对于文件的命名方式：

1. 文件路径名
2. 文件描述符

但是，将这两种命名解析到相应对象上的方式有所不同

+ 文件路径名在解析的时候是通过传入的路径（文件名，硬链接，软连接）间接解析的，其传入的参数并不是相应文件的真实地址 (inode)
+ 文件描述符通过访问直接指向文件的指针来解析

正是由于间接性，产生了时间窗口

例如程序在访问某个文件之前，会检查是否存在，之后会打开文件然后执行操作。但是如果在检查之后，真正使用文件之前，攻击者将文件修改为某个符号链接，那么程序将访问错误的文件

这种条件竞争出现的问题的根源在于文件系统中的名字对象绑定的问题。而下面的函数都会使用文件名作为参数：access(), open(), creat(), mkdir(), unlink(), rmdir(), chown(), symlink(), link(), rename(), chroot(),…

## CWE-364: Signal Handler Race Condition
条件竞争经常会发生在信号处理程序中，这是因为信号处理程序支持异步操作。尤其是当信号处理程序是不可重入的或者状态敏感的时候，攻击者可能通过利用信号处理程序中的条件竞争，可能可以达到拒绝服务攻击和代码执行的效果。比如说，如果在信号处理程序中执行了 free 操作，此时又来了一个信号，然后信号处理程序就会再次执行 free 操作，这时候就会出现 double free 的情况，再稍微操作一下，就可能可以达到任意地址写的效果了

一般来说，与信号处理程序有关的常见的条件竞争情况有

+ 信号处理程序和普通的代码段共享全局变量和数据段
+ 在不同的信号处理程序中共享状态
+ 信号处理程序本身使用不可重入的函数，比如 malloc 和 free 
+ 一个信号处理函数处理多个信号，这可能会进而导致 use after free 和 double free 漏洞
+ 使用 setjmp 或者 longjmp 等机制来使得信号处理程序不能够返回原来的程序执行流

## 概念
### 线程安全与可重入
#### 线程安全
即该函数可以被多个线程调用，而不会出现任何问题

条件：

+ 本身没有任何共享资源
+ 有共享资源，需要加锁

#### 可重用
一个函数可以被多个实例可以同时运行在相同的地址空间中

可重入函数可以被中断，并且其它代码在进入该函数时，不会丢失数据的完整性。所以可重入函数一定是线程安全的

可重入强调的是单个线程执行时，重新进入同一个子程序仍然是安全的

不满足条件

+ 函数体内使用了静态数据结构，并且不是常量
+ 函数体内使用了 malloc 或者 free 函数
+ 函数使用了标准 IO 函数
+ 调用的函数不是可重入的

可重入函数使用的所有变量都保存在调用栈的当前函数栈（frame）上

### 同步原语
一般来说，我们会使用同步原语来消除竞争条件。常见的如下

+ 锁变量

通常互斥琐，在等待期间放弃 CPU，进入 idle 状态，过一段时间自动尝试

自旋锁（spinlock），在等待期间不放弃 CPU，一直尝试

+ 条件变量

条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用

+ 临界区对象，CRITICAL_SECTION
+ 信号量（semaphore），控制可访问某个临界区的线程数量，一般比 1 大
+ 管道，指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件。其生存期不超过创建管道的进程的生存期
+ 命名管道，生存期可以与操作系统运行期一样长

### 死锁
当同步原语使用的不恰当的时候，进程就可能会出现死锁。当两个或两个以上的执行流互相阻塞导致都不能继续执行，死锁就会发生。其实，死锁主要是因为在冲突的执行流中，出现了循环等待的执行流，即循环等待中的每一个执行流都获得一个资源，同时试图获得下一个资源。下图所示，P1、P2 两个进程都需要资源才能继续运行。P1 拥有资源 R2、还需要额外资源 R1 才能运行；P2 拥有资源 R1、还需要额外资源 R2 才能运行，两边都在互相等待而没有任何一个可运行。

一般来说，死锁有以下四个必要条件

1. 互斥，资源是互斥的
2. 持有和等待，持有已有的资源，同时等待使用下一个资源
3. 不可抢占，进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放
4. 循环等待，循环等待资源

而如果想要消除死锁，也就是打破上面的四个必要条件

此外，死锁可能来源于以下的原因

+ 处理器速度
+ 进程或者线程调度算法的变动
+ 在执行的过程中，不同内存的限制
+ 任何能够中断程序执行的异步事件

死锁一般情况下会造成拒绝服务攻击

### 协程
+ 协程通过在线程中实现调度，避免了陷入内核级别的上下文切换造成的性能损失，进而突破了线程在 IO 上的性能瓶颈
+ 协程拥有自己的寄存器上下文和栈
+ 协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销



